package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"log"
	"os"
	"portfolio-api/ent"
	"portfolio-api/ent/user"
	"portfolio-api/utils/errCustom"
	"portfolio-api/utils/validation"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"golang.org/x/crypto/bcrypt"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input ent.CreateUserInput) (string, error) {
	isEmpty := validation.IsEmpty(input.Email)
	if isEmpty {
		return "", errCustom.Create("email is required")
	}

	isEmpty = validation.IsEmpty(input.Password)
	if isEmpty {
		return "", errCustom.Create("password is required")
	}

	isInvalid := validation.Email(input.Email)
	if isInvalid {
		return "", errCustom.Create("Invalid email")
	}

	u, err := r.Client.User.Query().Where(user.EmailEQ(input.Email)).Only(ctx)
	if err != nil {
		return "", err
	}

	err = bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(input.Password))
	if err != nil {
		return "", errCustom.Create("Invalid password")
	}

	// Create a jwt token
	// REF: https://pkg.go.dev/github.com/golang-jwt/jwt/v5#NewWithClaims
	claims := struct {
		jwt.RegisteredClaims
	}{
		jwt.RegisteredClaims{
			// A usual scenario is to set the expiration time relative to the current time
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
			NotBefore: jwt.NewNumericDate(time.Now()),
			Subject:   u.ID.String(),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	jwtSecretKey := os.Getenv("JWT_SECRET_KEY")
	if jwtSecretKey == "" {
		log.Fatal("jwtSecretKey is not set")
	}
	ss, err := token.SignedString([]byte(jwtSecretKey))
	if err != nil {
		return "", err
	}
	return ss, nil
}
